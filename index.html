<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kasatria Internship Assignment - 3D Visualization</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>

  <style>
    body { margin:0; overflow:hidden; background:#000; color:#fff; font-family: Helvetica, sans-serif; }
    #login-overlay { position: fixed; top:0; left:0; width:100%; height:100%; background:#111; display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:100; }
    #container { display:none; }
    #menu { position:absolute; bottom:20px; width:100%; text-align:center; display:none; }
    button { color: rgba(127,255,255,0.75); background: transparent; border: 1px solid rgba(127,255,255,0.75); padding: 8px 15px; cursor: pointer; margin: 5px; font-size: 11px; text-transform: uppercase; }
    button:hover { background-color: rgba(0,255,255,0.5); }

    .element { width:140px; height:180px; box-shadow: 0px 0px 12px rgba(0,255,255,0.5); border: 1px solid rgba(127,255,255,0.25); text-align:center; cursor:default; position:relative; }
    .element .name { position:absolute; top:10px; width:100%; font-size:11px; font-weight:bold; color:#fff; text-transform:uppercase; }
    .element .photo { position:absolute; top:35px; left:20px; width:100px; height:100px; border-radius:50%; border:2px solid #fff; object-fit:cover; background:#222; }
    .element .details { position:absolute; bottom:10px; width:100%; font-size:10px; color:#eee; line-height:1.2; }
  </style>
</head>
<body>

  <div id="login-overlay">
    <h1 style="margin-bottom:20px;">Sign In With Google</h1>
    <p style="color:#888; margin-bottom:30px;">Welcome Back! Please login to continue.</p>
    <div class="g_id_signin"></div>
  </div>

  <div id="container"></div>

  <div id="menu">
    <button id="table">Table</button>
    <button id="sphere">Sphere</button>
    <button id="helix">Helix</button>
    <button id="grid">Grid</button>
    <button id="pyramid">Pyramid</button>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
    import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';

    const SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQh16WP5uhuo9GmWBZC7ojq5yLAnCEhaZT6qtHKZxK0hwnZ-jmWYMvTd-PT8cIMDgutJxC2jJI6aJm0/pub?output=csv';

    let camera, scene, renderer, controls;
    const objects = [];
    const targets = { table: [], sphere: [], helix: [], grid: [], pyramid: [] };

    window.onload = function() {
      google.accounts.id.initialize({
        client_id: "674715063491-k6n894r4p9etin5629fa24kgba73d6hj.apps.googleusercontent.com",
        callback: handleCredentialResponse
      });
      google.accounts.id.renderButton(document.querySelector(".g_id_signin"), { theme: "outline", size: "large" });
    };

    function handleCredentialResponse(response) {
      document.getElementById('login-overlay').style.display = 'none';
      document.getElementById('container').style.display = 'block';
      document.getElementById('menu').style.display = 'block';
      loadData();
    }

    async function loadData() {
      try {
        const res = await fetch(SHEET_CSV_URL);
        const csvText = await res.text();
        const lines = csvText.split('\n').slice(1);
        const data = lines.map(line => line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(s => s.replace(/"/g,'').trim())).filter(item => item.length>=6);
        init(data);
        animate();
      } catch(err) {
        console.error(err);
      }
    }

    function init(data) {
      camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 1, 10000);
      camera.position.z = 3000;
      scene = new THREE.Scene();

      data.forEach((item, i) => {
        const [name, photo, age, country, interest, netWorthStr] = item;
        const netWorth = parseFloat(netWorthStr.replace(/[$,]/g,''));

        const element = document.createElement('div');
        element.className = 'element';
        element.style.backgroundColor = netWorth < 100000 ? 'rgba(239,48,34,0.75)' : netWorth > 200000 ? 'rgba(0,255,0,0.75)' : 'rgba(255,165,0,0.75)';

        element.innerHTML = `
          <div class="name">${name}</div>
          <img class="photo" src="${photo}" onerror="this.src='https://via.placeholder.com/100?text=No+Image'">
          <div class="details">${country} | Age: ${age}<br>${interest}<br><b>${netWorthStr}</b></div>
        `;

        const objectCSS = new CSS3DObject(element);
        objectCSS.position.set(Math.random()*4000-2000, Math.random()*4000-2000, Math.random()*4000-2000);
        scene.add(objectCSS);
        objects.push(objectCSS);

        const objTable = new THREE.Object3D();
        objTable.position.x = ((i % 20) * 180) - 1700;
        objTable.position.y = -(Math.floor(i / 20) * 210) + 900;
        targets.table.push(objTable);
      });

      const vector = new THREE.Vector3();

      // SPHERE
      for (let i = 0, l = objects.length; i < l; i++) {
        const phi = Math.acos(-1 + (2 * i) / l);
        const theta = Math.sqrt(l * Math.PI) * phi;
        const object = new THREE.Object3D();
        object.position.setFromSphericalCoords(800, phi, theta);
        vector.copy(object.position).multiplyScalar(2);
        object.lookAt(vector);
        targets.sphere.push(object);
      }

      // HELIX
      for (let i = 0, l = objects.length; i < l; i++) {
        const theta = i * 0.175 + Math.PI;
        const y = -(i * 8) + 450;
        const object = new THREE.Object3D();
        object.position.setFromCylindricalCoords(900, theta, y);
        vector.x = object.position.x * 2;
        vector.y = object.position.y;
        vector.z = object.position.z * 2;
        object.lookAt(vector);
        targets.helix.push(object);
      }

      // GRID
      for (let i = 0; i < objects.length; i++) {
        const object = new THREE.Object3D();
        object.position.x = ((i % 5) * 400) - 800;
        object.position.y = (-(Math.floor(i / 5) % 5) * 400) + 800;
        object.position.z = (Math.floor(i / 25)) * -1000 + 2000;
        targets.grid.push(object);
      }

      // --- IMPROVED ALIGNED PYRAMID LOGIC ---
      const size = 1200;
      const vPuncak = new THREE.Vector3(0, size, 0);
      const v1 = new THREE.Vector3(size, -size/2, size);
      const v2 = new THREE.Vector3(-size, -size/2, size);
      const v3 = new THREE.Vector3(0, -size/2, -size);

      const faces = [
        { a: vPuncak, b: v1, c: v2 },
        { a: vPuncak, b: v2, c: v3 },
        { a: vPuncak, b: v3, c: v1 },
        { a: v1, b: v2, c: v3 }
      ];

      let pyramidCount = 0;
      const itemsPerFace = Math.floor(objects.length / 4);
      const rowsPerFace = 12; 

      faces.forEach((face) => {
        for (let i = 0; i < rowsPerFace; i++) {
          const rowProgress = i / (rowsPerFace - 1);
          const colsInRow = i + 1;

          for (let j = 0; j < colsInRow; j++) {
            if (pyramidCount >= objects.length) break;

            const object = new THREE.Object3D();
            const colProgress = colsInRow > 1 ? j / (colsInRow - 1) : 0.5;

            const rowStart = new THREE.Vector3().lerpVectors(face.a, face.b, rowProgress);
            const rowEnd = new THREE.Vector3().lerpVectors(face.a, face.c, rowProgress);
            object.position.lerpVectors(rowStart, rowEnd, colProgress);

            const edge1 = new THREE.Vector3().subVectors(face.b, face.a);
            const edge2 = new THREE.Vector3().subVectors(face.c, face.a);
            const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
            const targetPos = new THREE.Vector3().copy(object.position).add(normal);
            object.lookAt(targetPos);

            targets.pyramid.push(object);
            pyramidCount++;
          }
        }
      });

      while (targets.pyramid.length < objects.length) {
        const filler = new THREE.Object3D();
        filler.position.set(0, -size, 0);
        targets.pyramid.push(filler);
      }

      renderer = new CSS3DRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('container').appendChild(renderer.domElement);

      controls = new TrackballControls(camera, renderer.domElement);
      controls.rotateSpeed = 0.5;
      controls.addEventListener('change', render);

      document.getElementById('table').onclick = () => transform(targets.table, 2000);
      document.getElementById('sphere').onclick = () => transform(targets.sphere, 2000);
      document.getElementById('helix').onclick = () => transform(targets.helix, 2000);
      document.getElementById('grid').onclick = () => transform(targets.grid, 2000);
      document.getElementById('pyramid').onclick = () => transform(targets.pyramid, 2000);

      transform(targets.table, 2000);
      window.addEventListener('resize', onWindowResize);
    }

    function transform(targets, duration) {
      TWEEN.removeAll();
      for (let i = 0; i < objects.length; i++) {
        const object = objects[i];
        const target = targets[i];
        new TWEEN.Tween(object.position).to({x:target.position.x, y:target.position.y, z:target.position.z}, Math.random()*duration+duration).easing(TWEEN.Easing.Exponential.InOut).start();
        new TWEEN.Tween(object.rotation).to({x:target.rotation.x, y:target.rotation.y, z:target.rotation.z}, Math.random()*duration+duration).easing(TWEEN.Easing.Exponential.InOut).start();
      }
      new TWEEN.Tween(this).to({}, duration*2).onUpdate(render).start();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    }

    function animate() {
      requestAnimationFrame(animate);
      TWEEN.update();
      controls.update();
    }

    function render() { renderer.render(scene, camera); }
  </script>
</body>
</html>
